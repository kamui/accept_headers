{"name":"Accept headers","tagline":"A ruby library that parses and sorts http accept headers.","body":"[![Build Status](https://travis-ci.org/kamui/accept_headers.png)](https://travis-ci.org/kamui/accept_headers)\r\n[![Code Climate](https://codeclimate.com/github/kamui/accept_headers/badges/gpa.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n[![Test Coverage](https://codeclimate.com/github/kamui/accept_headers/badges/coverage.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n\r\n# AcceptHeaders\r\n\r\n**AcceptHeaders** is a ruby library that parses and sorts http accept headers.\r\n\r\nSome features of the library are:\r\n\r\n  * Strict adherence to [RFC 2616][rfc], specifically [section 14][rfc-sec14]\r\n  * Full support for the [Accept][rfc-sec14-1], [Accept-Charset][rfc-sec14-2],\r\n    [Accept-Encoding][rfc-sec14-3], and [Accept-Language][rfc-sec14-4] HTTP\r\n    request headers\r\n  * A comprehensive [spec suite][spec] that covers many edge cases\r\n\r\nThis library is optimistic when parsing headers. If a specific media type, encoding, charset, or language can't be parsed, is in an invalid format, or contains invalid characters, it will skip that specific entry when constructing the sorted list. If a `q` value can't be read or is in the wrong format (more than 3 decimal places), it will default it to `0.001` so it still has a chance to match. Lack of an explicit `q` value of course defaults to 1.\r\n\r\n[rfc]: http://www.w3.org/Protocols/rfc2616/rfc2616.html\r\n[rfc-sec14]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\r\n[rfc-sec14-1]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\r\n[rfc-sec14-2]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2\r\n[rfc-sec14-3]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\r\n[rfc-sec14-4]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\r\n[spec]: http://github.com/kamui/accept_headers/tree/master/spec/\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'accept_headers'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install accept_headers\r\n\r\n## Usage\r\n\r\n`AcceptHeaders` can parse the Accept Header and return an array of `MediaType`s in descending order according to the spec, which takes into account `q` value, `type`/`subtype` and `params` specificity.\r\n\r\n```ruby\r\nAcceptHeaders::MediaType.parse(\"text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\")\r\n```\r\n\r\nWill generate this equivalent array:\r\n\r\n```ruby\r\n[\r\n  MediaType.new('text', 'html', params: { 'level' => '1' }),\r\n  MediaType.new('text', 'html', q: 0.7),\r\n  MediaType.new('*', '*', q: 0.5),\r\n  MediaType.new('text', 'html', q: 0.4, params: { 'level' => '2' }),\r\n  MediaType.new('text', '*', q: 0.3)\r\n]\r\n```\r\n\r\nParsing `Charset`:\r\n\r\n```ruby\r\nAcceptHeaders::Charset.parse(\"us-ascii; q=0.5, iso-8859-1, utf-8; q=0.8, macintosh\")\r\n```\r\n\r\ngenerates:\r\n\r\n```ruby\r\n[\r\n  Charset.new('iso-8859-1'),\r\n  Charset.new('macintosh'),\r\n  Charset.new('utf-8', q: 0.8),\r\n  Charset.new('us-ascii', q: 0.5)\r\n]\r\n```\r\n\r\nParsing `Encoding`:\r\n\r\n```ruby\r\nAcceptHeaders::Encoding.parse(\"deflate; q=0.5, gzip, compress; q=0.8, identity\")\r\n```\r\n\r\ngenerates:\r\n\r\n```ruby\r\n[\r\n  Encoding.new('gzip'),\r\n  Encoding.new('identity'),\r\n  Encoding.new('compress', q: 0.8),\r\n  Encoding.new('deflate', q: 0.5)\r\n]\r\n```\r\n\r\nParsing `Language`:\r\n\r\n```ruby\r\nAcceptHeaders::Language.parse(\"en-*, en-us, *;q=0.8\")\r\n```\r\n\r\ngenerates:\r\n\r\n```ruby\r\n[\r\n  Language.new('en', 'us'),\r\n  Language.new('en', '*'),\r\n  Language.new('*', '*', q: 0.8)\r\n]\r\n```\r\n## Todo\r\n\r\n* Write rack middleware\r\n* Add methods to return a best match depending on a list of supported inputs\r\n\r\n## Contributing\r\n\r\n1. Fork it ( https://github.com/[my-github-username]/accept_headers/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"UA-18119942-1","note":"Don't delete this file! It's used internally to help with page regeneration."}