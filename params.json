{"name":"Accept headers","tagline":"A ruby library that does content negotiation and parses and sorts http accept headers","body":"[![Build Status](https://travis-ci.org/kamui/accept_headers.png)](https://travis-ci.org/kamui/accept_headers)\r\n[![Code Climate](https://codeclimate.com/github/kamui/accept_headers/badges/gpa.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n[![Test Coverage](https://codeclimate.com/github/kamui/accept_headers/badges/coverage.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n\r\n# AcceptHeaders\r\n\r\n**AcceptHeaders** is a ruby library that does content negotiation and parses and sorts http accept headers.\r\n\r\nSome features of the library are:\r\n\r\n  * Strict adherence to [RFC 2616][rfc], specifically [section 14][rfc-sec14]\r\n  * Full support for the [Accept][rfc-sec14-1], [Accept-Encoding][rfc-sec14-3],\r\n    and [Accept-Language][rfc-sec14-4] HTTP request headers\r\n  * `Accept-Charset` is not supported because it's [obsolete](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-Charset.3A_header)\r\n  * Parser tested against all IANA registered [media types][iana-media-types]\r\n  * A comprehensive [spec suite][spec] that covers many edge cases\r\n\r\nThis library is optimistic when parsing headers. If a specific media type, encoding, or language can't be parsed, is in an invalid format, or contains invalid characters, it will skip that specific entry when constructing the sorted list. If a `q` value can't be read or is in the wrong format (more than 3 decimal places), it will default it to `0.001` so it still has a chance to match. Lack of an explicit `q` value of course defaults to 1.\r\n\r\n[rfc]: http://www.w3.org/Protocols/rfc2616/rfc2616.html\r\n[rfc-sec14]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\r\n[rfc-sec14-1]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\r\n[rfc-sec14-3]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\r\n[rfc-sec14-4]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\r\n[iana-media-types]: https://www.iana.org/assignments/media-types/media-types.xhtml\r\n[spec]: http://github.com/kamui/accept_headers/tree/master/spec/\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'accept_headers'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install accept_headers\r\n\r\n## Usage\r\n\r\n### Accept\r\n\r\n`AcceptHeaders::MediaType::Negotiator` is a class that is initialized with an `Accept` header string and will internally store an array of `MediaType`s in descending order according to the spec, which takes into account `q` value, `type`/`subtype` and `params` specificity.\r\n\r\n```ruby\r\nmedia_types = AcceptHeaders::MediaType::Negotiator.new(\"text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\")\r\n\r\nmedia_types.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::MediaType.new('text', 'html', params: { 'level' => '1' }),\r\n  AcceptHeaders::MediaType.new('text', 'html', q: 0.7),\r\n  AcceptHeaders::MediaType.new('*', '*', q: 0.5),\r\n  AcceptHeaders::MediaType.new('text', 'html', q: 0.4, params: { 'level' => '2' }),\r\n  AcceptHeaders::MediaType.new('text', '*', q: 0.3)\r\n]\r\n```\r\n\r\n`#negotiate` takes a string of media types supported (by your API or route/controller) and returns the best match as a `MediaType`. This will first check the available list for any matching media types with a `q` of 0 and return `nil` if there is a match. Then it'll look to the highest `q` values and look for matches in descending `q` value order and return the first match (accounting for wildcards). Finally, if there are no matches, it returns `nil`.\r\n\r\n```ruby\r\nmedia_types.negotiate('text/html')\r\n\r\n# Returns:\r\n\r\nAcceptHeaders::MediaType.new('text', 'html', params: { 'level' => '1' })\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nmedia_types.accept?('text/html') # true\r\n```\r\n\r\n### Accept-Encoding\r\n\r\n`AcceptHeader::Encoding::Encoding`:\r\n\r\n```ruby\r\nencodings = AcceptHeaders::Encoding::Negotiator.new(\"deflate; q=0.5, gzip, compress; q=0.8, identity\")\r\n\r\nencodings.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::Encoding.new('gzip'),\r\n  AcceptHeaders::Encoding.new('compress', q: 0.8),\r\n  AcceptHeaders::Encoding.new('deflate', q: 0.5)\r\n]\r\n```\r\n\r\n`#negotiate`:\r\n\r\n```ruby\r\nencodings.negotiate('gzip')\r\n\r\n# Returns:\r\n\r\nAcceptHeaders::Encoding.new('gzip')\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nencodings.accept?('gzip') # true\r\n\r\n# Identity is accepted as long as it's not explicitly rejected 'identity;q=0'\r\n\r\nencodings.accept?('identity') # true\r\n```\r\n\r\n### Accept-Language\r\n\r\n`Accept::Language::Negotiator`:\r\n\r\n```ruby\r\nlanguages = AcceptHeaders::Language::Negotiator.new(\"en-*, en-us, *;q=0.8\")\r\n\r\nlanguages.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::Language.new('en', 'us'),\r\n  AcceptHeaders::Language.new('en', '*'),\r\n  AcceptHeaders::Language.new('*', '*', q: 0.8)\r\n]\r\n```\r\n\r\n`#negotiate`:\r\n\r\n```ruby\r\nlanguages.negotiate('en-us')\r\n\r\n# Returns:\r\n\r\nAcceptHeaders::Language.new('en', 'us')\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nlanguages.accept?('en-gb') # true\r\n```\r\n\r\n## TODO\r\n\r\n* Write rack middleware\r\n* More edge case tests\r\n* Add rdoc\r\n\r\n## Contributing\r\n\r\n1. Fork it ( https://github.com/[my-github-username]/accept_headers/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"UA-18119942-1","note":"Don't delete this file! It's used internally to help with page regeneration."}