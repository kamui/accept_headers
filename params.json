{"name":"Accept headers","tagline":"A ruby library that does content negotiation and parses and sorts http accept headers","body":"[![Build Status](https://travis-ci.org/kamui/accept_headers.png)](https://travis-ci.org/kamui/accept_headers)\r\n[![Code Climate](https://codeclimate.com/github/kamui/accept_headers/badges/gpa.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n[![Test Coverage](https://codeclimate.com/github/kamui/accept_headers/badges/coverage.svg)](https://codeclimate.com/github/kamui/accept_headers)\r\n\r\n# AcceptHeaders\r\n\r\n**AcceptHeaders** is a ruby library that does content negotiation and parses and sorts http accept headers.\r\n\r\nSome features of the library are:\r\n\r\n  * Strict adherence to [RFC 2616][rfc], specifically [section 14][rfc-sec14]\r\n  * Full support for the [Accept][rfc-sec14-1], [Accept-Encoding][rfc-sec14-3],\r\n    and [Accept-Language][rfc-sec14-4] HTTP request headers\r\n  * `Accept-Charset` is not supported because it's [obsolete](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-Charset.3A_header)\r\n  * Parser tested against all IANA registered [media types][iana-media-types] and [encodings][iana-encodings]\r\n  * A comprehensive [spec suite][spec] that covers many edge cases\r\n\r\nThis library is optimistic when parsing headers. If a specific media type, encoding, or language can't be parsed, is in an invalid format, or contains invalid characters, it will skip that specific entry when constructing the sorted list. If a `q` value can't be read or is in the wrong format (more than 3 decimal places), it will default it to `0.001` so it still has a chance to match. Lack of an explicit `q` value of course defaults to 1.\r\n\r\n[rfc]: http://www.w3.org/Protocols/rfc2616/rfc2616.html\r\n[rfc-sec14]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\r\n[rfc-sec14-1]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1\r\n[rfc-sec14-3]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\r\n[rfc-sec14-4]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\r\n[iana-media-types]: https://www.iana.org/assignments/media-types/media-types.xhtml\r\n[iana-encodings]: https://www.iana.org/assignments/http-parameters/http-parameters.xml#content-coding\r\n[spec]: http://github.com/kamui/accept_headers/tree/master/spec/\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'accept_headers'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install accept_headers\r\n\r\n## Usage\r\n\r\n### Accept\r\n\r\n`AcceptHeaders::MediaType::Negotiator` is a class that is initialized with an `Accept` header string and will internally store an array of `MediaType`s in descending order according to the spec, which takes into account `q` value, `type`/`subtype` and `extensions` specificity.\r\n\r\n```ruby\r\naccept_header = 'Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5'\r\nmedia_types = AcceptHeaders::MediaType::Negotiator.new(accept_header)\r\n\r\nmedia_types.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::MediaType.new('text', 'html', extensions: { 'level' => '1' }),\r\n  AcceptHeaders::MediaType.new('text', 'html', q: 0.7),\r\n  AcceptHeaders::MediaType.new('*', '*', q: 0.5),\r\n  AcceptHeaders::MediaType.new('text', 'html', q: 0.4, extensions: { 'level' => '2' }),\r\n  AcceptHeaders::MediaType.new('text', '*', q: 0.3)\r\n]\r\n```\r\n\r\n`#negotiate` takes an array of media range strings supported (by your API or route/controller) and returns the best supported `MediaType` and the `extensions` params from the matching internal media type.\r\n\r\nThis will first check the available list for any matching media types with a `q` of 0 and skip any matches. It does this because the RFC specifies that if the `q` value is 0, then content with this parameter is `not acceptable`. Then it'll look to the highest `q` values and look for matches in descending `q` value order and return the first match (accounting for wildcards). Finally, if there are no matches, it returns `nil`.\r\n\r\n```ruby\r\n# The same media_types variable as above\r\nmedia_types.negotiate(['text/html', 'text/plain'])\r\n\r\n# Returns this equivalent:\r\n\r\nAcceptHeader::MediaType.new('text', 'html', extensions: { 'level' => '1' })\r\n```\r\n\r\nIt returns the matching `MediaType`, so you can see which one matched and also access the `extensions` params. For example, if you wanted to put your API version in the extensions, you could then retrieve the value.\r\n\r\n```ruby\r\nversions_header = 'Accept: application/json;version=2,application/json;version=1;q=0.8'\r\nmedia_types = AcceptHeaders::MediaType::Negotiator.new(versions_header)\r\n\r\nm = media_types.negotiate('application/json')\r\nputs m.extensions['version'] # returns '2'\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nmedia_types.accept?('text/html') # true\r\n```\r\n\r\n### Accept-Encoding\r\n\r\n`AcceptHeader::Encoding::Encoding`:\r\n\r\n```ruby\r\naccept_encoding = 'Accept-Encoding: deflate; q=0.5, gzip, compress; q=0.8, identity'\r\nencodings = AcceptHeaders::Encoding::Negotiator.new(accept_encoding)\r\n\r\nencodings.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::Encoding.new('gzip'),\r\n  AcceptHeaders::Encoding.new('compress', q: 0.8),\r\n  AcceptHeaders::Encoding.new('deflate', q: 0.5)\r\n]\r\n```\r\n\r\n`#negotiate`:\r\n\r\n```ruby\r\nencodings.negotiate(['gzip', 'compress'])\r\n\r\n# Returns this equivalent:\r\n\r\nAcceptHeader::Encoding.new('gzip')\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nencodings.accept?('gzip') # true\r\n\r\n# Identity is accepted as long as it's not explicitly rejected 'identity;q=0'\r\n\r\nencodings.accept?('identity') # true\r\n```\r\n\r\n### Accept-Language\r\n\r\n`Accept::Language::Negotiator`:\r\n\r\n```ruby\r\naccept_language = 'Accept-Language: en-*, en-us, *;q=0.8'\r\nlanguages = AcceptHeaders::Language::Negotiator.new(accept_language)\r\n\r\nlanguages.list\r\n\r\n# Returns:\r\n\r\n[\r\n  AcceptHeaders::Language.new('en', 'us'),\r\n  AcceptHeaders::Language.new('en', '*'),\r\n  AcceptHeaders::Language.new('*', '*', q: 0.8)\r\n]\r\n```\r\n\r\n`#negotiate`:\r\n\r\n```ruby\r\nlanguages.negotiate(['en-us', 'zh-Hant'])\r\n\r\n# Returns this equivalent:\r\n\r\nAcceptHeaders::Language.new('en', 'us')\r\n```\r\n\r\n`#accept?`:\r\n\r\n```ruby\r\nlanguages.accept?('en-gb') # true\r\n```\r\n\r\n## Rack Middleware\r\n\r\nAdd the middleware:\r\n\r\n```ruby\r\nrequire 'accept_headers/middleware'\r\nuse AcceptHeaders::Middleware\r\nrun YourApp\r\n```\r\n\r\nSimple way to set the content response headers based on the request accept headers and the supported media types, encodings, and languages provided by the app or route.\r\n\r\n```ruby\r\nclass YourApp\r\n  def initialize(app)\r\n    @app = app\r\n  end\r\n\r\n  def call(env)\r\n    # List your arrays of supported media types, encodings, languages. This can be global or per route/controller\r\n    supported_media_types = %w[application/json application/xml text/html text/plain]\r\n    supported_encodings = %w[gzip identify]\r\n    supported_languages = %w[en-US en-GB]\r\n\r\n    # Call the Negotiators and pass in the supported arrays and it'll return the best match\r\n    matched_media_type = env[\"accept_headers.media_types\"].negotiate(supported_media_types)\r\n    matched_encoding = env[\"accept_headers.encodings\"].negotiate(supported_encodings)\r\n    matched_language = env[\"accept_headers.languages\"].negotiate(supported_languages)\r\n\r\n    # Set a default, in this case an empty string, in case of a bad header that cannot be parsed\r\n    # The return value is a MediaType, Encoding, or Language depending on the case:\r\n    # On MediaType, you can call #type ('text'), #subtype ('html'), #media_range ('text/html') to get the stringified parts\r\n    # On Encoding, you can call #encoding to get the string encoding ('gzip')\r\n    # On Language, you can call #primary_tag ('en'), #subtag ('us'), or #language_tag ('en-us')\r\n    headers = {\r\n      'Content-Type' => matched_media_type ? matched_media_type.media_range : '',\r\n      'Content-Encoding' => matched_encoding ? matched_encoding.encoding : '',\r\n      'Content-Language' => matched_language ? matched_language.language_tag : '',\r\n    }\r\n\r\n    [200, headers, [\"Hello World!\"]]\r\n  end\r\nend\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it ( https://github.com/[my-github-username]/accept_headers/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"UA-18119942-1","note":"Don't delete this file! It's used internally to help with page regeneration."}